## Модуль разметки эссе
Путь импорта модуля: `baseline.markup`  
Точка входа класс `Marker` (singleton), при создании объекта инициализируется определенная 
реализация класса разметчика `MarkupAbstract`, за это отвечает фабрика `MarkupFactory`.  

Для смены стандартной реализации `MarkupDemo` (она подставляет определенную разметку на основе предмета эссе),
можно из клиентского кода создать объект фабрики `MarkupFactory` и установить у него другую реализацию.
```python
markup_factory = MarkupFactory()
markup_factory.set(MarkupSuperAI())
```

> `MarkupDemo` просто подставляет определенную разметку из словаря на основе предмета эссе
> эту реализацию не следует использовать для квалификаций!


`Marker` как и `MarkupAbstract` должны иметь 2 метода, один с асинхронным (async/await) вызовом, второй с синхронным вызовом.  
Асинхронный режим работы применяется в сессии обмена. Если при реализации класса разметки нет необходимости асинхронной работы, то можно либо: 
- просто объявить метод `async` и просто вернуть результат синхронного вызова (см. пример в `MarkupDemo`)  
    > Рекомендую этого избегать, т.к. есть риск, что синхронный вызов заблокирует весь поток. Решение подойдет если операция не тяжелая и быстрая
- использовать `asyncio.to_thread(blocking_io)`, где blocking_io - это синхронный метод который нужно вызвать
    Аргументы в метод можно передавать указав их в вызове [asyncio.to_thread](https://docs.python.org/3/library/asyncio-task.html#asyncio.to_thread) после указания синхронного метода 
Синхронный вариант можно, например, использовать для разметки файла при вызове из консольного интерфейса.