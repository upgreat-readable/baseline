## Модуль сессий обмена с платформой
Путь импорта модуля: `baseline.session`  
Отвечает за управление сессиями обмена эссе с платформой `http://readable.upgreat.one/` в ходе обучающих, квалификационных и финальных испытаний.  
Работает в асинхронном режиме, т.е. запускает event loop и вс.
На данным момент взаимодействие с платформой построено на протоколе websocket, конкретно используется надстройка над протоколом - socketio.  
В зависимостях модуля:
- [python-socketio["asyncio-client"]](https://python-socketio.readthedocs.io/en/latest/api.html#socketio.AsyncClient)
- [aiohttp](https://docs.aiohttp.org/en/stable/)
> **важно!!!** соблюдать версию пакета (~=4.6, <5), т.к. Nestjs gateway поддерживает только 2 версию протокола socketio, ждем 8й версии nestjs чтобы обновить пакет
> [подробнее](https://github.com/nestjs/nest/issues/5676)

Для начала работы с сессиями необходимо указать токен участника (TOKEN) в файле `.env` из корня проекта. Токен можно получить в ЛК участника платформы Про\\чтение.  
Так же предусмотрен дебаг режим, активируется при помощи переменной окружения `DEBUG` в файле `.env` из корня проекта.  
В дебаг режиме выводится более детальный лог работы обмена и формируется файла `logs/debug_{time}.log` в который пишутся сериализованные сообщения .

Реализованы абстракция подключения к платформе `baseline.session.connector.session_connector_abstract` и стандартная реализация `baseline.session.connector.session_websocket_connector`.  
Вся логика работы с протоколом обмена и инициализации разметки полученного эссе вынесена в коннектор
В случае необходимости реализации своего коннектора, необходимо наследоваться от абстрактного коннектора и придерживаться протокола обмена с платформой, после заменить в `SessionConnectorFactory` вызываемый класс.  
[Протокол обмена с платформой](session-protocol.md)

Точка входа в модуль это класс Session который предоставляет интерфейс для:
- старта сессии, с параметрами старта
- отмены сессии
- реконнекта к активной сессии
- отправки файла эссе в ходе сессии
- ~~получения актуального файла в рамках сессии (функция ещё не реализована на платформе)~~

Когда, в рамках сессии обмена, приходит файл эссе, происходит асинхронный вызов Модуля Разметки, на вход которого передается полученное эссе, а как результат ожидается эссе с блоком `selections`.  
Как только эссе было размечено и возвращено управление в коннектор, происходит отправка результата на платформу Про\\чтение.

#### Краткое описание процесса сессии
1) При установке коннекта с платформой, происходит автоматическая проверка на наличие активной сессии и подключение в неё, если таковая имеется.  
    После подключения к сессии, клиент ожидает события доступности файла.  
2) Когда файла эссе становится доступным, в сообщении этого события приходит весь контент файла. 
    Получив файл, создается объект эссе (`EssayAbstract`), и его содержимое сохраняется на диск в директорию `files/sessions/{session_id}/input`, имя файла строится из id файла и расширения json.  
3) После сохранения файла управление передается в модуль разметки, конкретная реализация способа разметки проводит необходимые операции над файлом.  
    Итогом разметки должен быть такой же объект эссе (`EssayAbstract`), но содержащий в себе фрагменты разметки.  
    Фрагменты разметки должны являться объектами класса `SelectionAbstract` модуля эссе и помещаются в коллекцию фрагментов `SelectionCollection`.  
    Демонстрация на примере реализации деморазметки:
    ```python
    # method: __execute; class: baseline.markup.implementation.MarkupDemo
    demo_selection = self.__DEMO_SELECTION_BY_SUBJECT.get(essay.meta.subject)
    markup_essay = essay.copy()
    selection = Selection()
    selection.fill(demo_selection)
    markup_essay.selections.append(selection)
    ```
4) Модуль разметки возвращает результат в модуль сессии, который отправляет размеченный файл эссе на платформу.
5) После передачи всех файлов сессия останавливает передавая соответствующий сигнал клиенту, после чего происходит дисконнект с платформой.